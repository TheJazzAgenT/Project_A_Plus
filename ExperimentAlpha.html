
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Homework 3 Part B</title>
		<meta charset="utf-8">
		<style>
			body {
			  	margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
<body>

<div id="container"></div>

    <script src="js/three.js"></script>
    <script id="vertexShader" type="x-shader/x-vertex">


	uniform mat4 modelViewMatrix;
	uniform mat4 projectionMatrix;
	
    attribute vec3 position;
	
	void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
	}

    </script>


    <script id="fragmentShader" type="x-shader/x-fragment">
	precision mediump float;
	uniform float rx, ry, time;
	
	uniform sampler2D t1;
	vec2 texCoord;
	
	vec2 uv;

float rnd(float rx)
{
    return fract(sin(dot(vec2(rx+47.49,38.2467/(rx+2.3)), vec2(12.9898, 78.233)))* (43758.5453));
}

float drawCircle(vec2 center, float radius)
{
    return 1.0 - smoothstep(0.0, radius, length(uv - center));
}


void main()
{
    uv = gl_FragCoord.xy / vec2(rx, ry);
	texCoord = gl_FragCoord.xy / vec2(rx, ry);
    gl_FragColor = vec4(1.0, 0.0, 0.0, 0.0);
    float j;
    
    for(int i = 0; i < 200; i++)
    {
        j = float(i);
        float speed = 0.01+rnd(cos(j))*(0.7+0.5*cos(j/(float(200)*0.25)));
        vec2 center = vec2((0.25-uv.y)*0.2+rnd(j)+0.1*cos((time*0.1)+sin(j)), mod(sin(j)-speed*(time*0.1*(0.1+0.3)), 1.0));
		float weird = 0.8*drawCircle(center, 0.002+speed*0.012);
        gl_FragColor += vec4(weird, weird, weird, 0.5);
    }
}
	</script>
	
	<script id="fragmentShader2" type="x-shader/x-fragment">
	precision mediump float;

void main()
{
  gl_FragColor = vec4(0.0,0.0,1.0,1.0);
}
	</script>

	<script>
				
  	var container;

	var camera, scene, renderer;
	var tex1 = new THREE.TextureLoader().load( 'valley-of-light-salat.jpg' );
    var vs = document.getElementById( 'vertexShader' ).textContent;
    var fs = document.getElementById( 'fragmentShader' ).textContent;
	var fs2 = document.getElementById( 'fragmentShader2' ).textContent;
	var mesh;
	
	init();
	animate();


	function init() {

		container = document.getElementById( 'container' );

		camera = new THREE.PerspectiveCamera( 60.0, window.innerWidth / window.innerHeight, 0.1, 50 );
		camera.position.z = 2;
		var width = window.innerWidth;
		var height = window.innerHeight;

		scene = new THREE.Scene();

		
		var plane = new THREE.PlaneBufferGeometry( window.innerWidth, window.innerHeight );
		var plane2 = new THREE.PlaneBufferGeometry( window.innerWidth, window.innerHeight );
		var uniforms = {
            rx: {type: "f", value: window.innerWidth},
            ry: {type: "f", value: window.innerHeight},
			time: {type: "f", value: 0.0},
			t1: {type: "t", value: tex1},
        };
		var material = new THREE.RawShaderMaterial( {
			uniforms: uniforms,
			vertexShader: vs,
			fragmentShader: fs,
		} );
		var uniforms2 = {
            rx: {type: "f", value: window.innerWidth},
            ry: {type: "f", value: window.innerHeight},
			time: {type: "f", value: 0.0},
			t1: {type: "t", value: tex1},
        };
		var material2 = new THREE.RawShaderMaterial( {
			uniforms: uniforms2,
			vertexShader: vs,
			fragmentShader: fs2,
		} );

		var fullScreenQuad = new THREE.Mesh( plane, material );
		scene.add(fullScreenQuad);
		var fullScreenQuad2 = new THREE.Mesh( plane2, material2 );
		fullScreenQuad2.translateZ(-0.5);
		scene.add(fullScreenQuad2);
		

		renderer = new THREE.WebGLRenderer();
		renderer.setClearColor( 0x999999 );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );


		//make it so that resizing the browser window also resizes the scene
		window.addEventListener( 'resize', onWindowResize, false );
		
	}

	function animate() {

		requestAnimationFrame( animate );
		render();

	}

	function render() {

		var time = performance.now();
		var object1 = scene.children[ 0 ];
		object1.material.uniforms.time.value = time * 0.005;
		renderer.render( scene, camera );
		
	}

	function onWindowResize( event ) {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}


		</script>

	</body>
</html>