
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>A Really Cold Place</title>
		<meta charset="utf-8">
		<style>
			body {
			  margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>

    <script src="../js/three.js"></script>
    <script src="../js/OrbitControls.js"></script>
    <script src="../js/dat.gui.min.js"></script>
  	<script src="../js/Iceland.js"></script>
		<script src="../shader/vertexShader_hmap.js"></script>
		<script src="../shader/fragShader_hmap.js"></script>
		
	<script id="snowSDF/VS" type="x-shader/x-vertex">
	uniform mat4 modelViewMatrix;
	uniform mat4 projectionMatrix;
    attribute vec3 position;
	void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
	}
    </script>
	<script id="snowSDF/FS" type="x-shader/x-fragment">
	precision mediump float;
	uniform float rx, ry, time;
	uniform sampler2D textureBuffer;
	vec2 uv;
	float rnd(float rx)
	{
		return fract(sin(dot(vec2(rx+47.49,38.2467/(rx+2.3)), vec2(12.9898, 78.233)))* (43758.5453));
	}
	float drawCircle(vec2 center, float radius)
	{
		return 1.0 - smoothstep(0.0, radius, length(uv - center));
	}
	void main()
	{
		uv = gl_FragCoord.xy / vec2(rx, ry);
		gl_FragColor = texture2D(textureBuffer, uv);
		float j;
		for(int i = 0; i < 200; i++)
		{
			j = float(i);
			float speed = 0.01+rnd(cos(j))*(0.7+0.5*cos(j/(float(210)*0.25)));
			vec2 center = vec2((0.25-uv.y)*0.2+rnd(j)+0.1*cos((time*0.05)+sin(j)), mod(sin(j)-speed*(time*0.1*(0.1+0.2)), 1.0));
			gl_FragColor += vec4(0.65*drawCircle(center, 0.002+speed*0.012));
		}
	}
	</script>
	
  <script id="skyboxVS" type="x-shader/x-vertex">

	uniform mat4 modelMatrix;
	uniform mat4 viewMatrix;
  uniform mat4 projectionMatrix;

  attribute vec3 position;

	varying vec3 vWorldPosition;

	void main() {
		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
		vWorldPosition = worldPosition.xyz;

		vec4 p = viewMatrix * modelMatrix * vec4(position, 1.0);
		gl_Position = projectionMatrix * p;
  }
    </script>

    <script id="skyboxFS" type="x-shader/x-fragment">
		precision mediump float;
		uniform samplerCube tCube;
		varying vec3 vWorldPosition;

		void main() {
			gl_FragColor = textureCube( tCube, vec3(  vWorldPosition ) );
		}
    </script>
    <script id="seaVS" type="x-shader/x-vertex">
  #define SCALE 10.0

	uniform mat4 modelMatrix;
	uniform mat4 viewMatrix;
  uniform mat4 projectionMatrix;
  uniform vec3 cameraPosition;
  uniform float uTime;

  attribute vec3 position;
  attribute vec3 normal;
  attribute vec2 uv;

  varying vec2 vUv;
  varying vec3 vI;
	varying vec3 vWorldNormal;

  float calculateSurface(float x, float z) {
    float y = 0.0;
    y += (sin(x * 1.0 / SCALE + uTime * 1.0) + sin(x * 2.3 / SCALE + uTime * 1.5) + sin(x * 3.3 / SCALE + uTime * 0.4)) / 3.0;
    y += (sin(z * 0.2 / SCALE + uTime * 1.8) + sin(z * 1.8 / SCALE + uTime * 1.8) + sin(z * 2.8 / SCALE + uTime * 0.8)) / 3.0;
    return y;
  }

	void main() {
    vUv = uv;
		//vec4 mvPosition = viewMatrix * modelMatrix * vec4( position, 1.0 );
    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );

    vWorldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );

    vI = worldPosition.xyz - cameraPosition;

    float strength = 0.2;
    vec3 pos = position;
    pos.z += strength * calculateSurface(pos.x, pos.y);
    //gl_Position = projectionMatrix * mvPosition;
    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(pos, 1.0);
  }
    </script>

    <script id="seaFS" type="x-shader/x-fragment">
		precision mediump float;
		uniform sampler2D seaTex;
    uniform samplerCube envMap;
    uniform float reflectiveness;

    varying vec2 vUv;
		varying vec3 vI, vWorldNormal;

    vec3 m_refract(vec3 I, vec3 N, float ior)
    {
      float cosi = clamp(dot(I, N), -1.0, 1.0);
      float etai = 1.0, etat = ior;
      vec3 n = N;
      if (cosi < 0.0) {
        cosi = -cosi;
      }
      else {
        float temp = etai;
        etai = etat;
        etat = temp;
        n = -N;
      }
      float eta = etai / etat;
      float k = 1.0 - eta * eta * (1.0 - cosi * cosi);
      return k < 0.0 ? vec3(0.0) : eta * I + (eta * cosi - sqrt(k)) * n;
    }

    float fresnel(vec3 I, vec3 N, float ior)
    {
      float kr;
      float cosi = clamp(dot(I, N), -1.0, 1.0);
      float etai = 1.0, etat = ior;
      if (cosi > 0.0) {
        float temp = etai;
        etai = etat;
        etat = temp;
      }
      // Compute sini using Snell's law
      float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));
      // Total internal reflection
      if (sint >= 1.0) {
        kr = 1.0;
      }
      else {
        float cost = sqrt(max(0.0, 1.0 - sint * sint));
        cosi = abs(cosi);
        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));
        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));
        kr = (Rs * Rs + Rp * Rp) / 2.0;
      }
      return kr;
      // As a consequence of the conservation of energy, transmittance is given by:
      // kt = 1 - kr;
    }

		void main() {
      vec3 reflection = reflect( vI, vWorldNormal );
      vec3 refraction = m_refract(vI, vWorldNormal, 1.3);
      float fv = fresnel(vI, vWorldNormal, 1.3);
      vec4 reflectColor = textureCube( envMap, vec3( -reflection.x, reflection.yz ) );
      vec4 refractColor = textureCube( envMap, refraction );
      gl_FragColor = vec4(fv, fv, fv, 1.0);
      gl_FragColor = reflectColor * fv + refractColor * (1.0 - fv);
      //gl_FragColor = refractColor;
		}
    </script>

	<script>
var container;
var options, camera, scene, renderer;
var skyMesh;
var iceland;
var sb_vs = document.getElementById( 'skyboxVS' ).textContent;
var sb_fs = document.getElementById( 'skyboxFS' ).textContent;
var sea_vs = document.getElementById( 'seaVS' ).textContent;
var sea_fs = document.getElementById( 'seaFS' ).textContent;
var snow_vs = document.getElementById( 'snowSDF/VS' ).textContent;
var snow_fs = document.getElementById( 'snowSDF/FS' ).textContent;
var texture2 = new THREE.TextureLoader().load( 'sea.png' );
//gui = new dat.GUI( { width: 350 } );
//Buffer Items
var bufferObject = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );
var bufferScene = new THREE.Scene();
var bufferCamera;

init();
animate();

function init() {
	container = document.getElementById( 'container' );
	camera = new THREE.PerspectiveCamera( 60.0, window.innerWidth / window.innerHeight, 0.1, 50 );
	camera.position.z = 2.0;
	bufferCamera = new THREE.PerspectiveCamera( 60.0, window.innerWidth / window.innerHeight, 0.1, 2000 );
	//adds a default mouse listener to control the camera rotation and zoom
	var controls = new THREE.OrbitControls( bufferCamera );
	bufferCamera.position.z = 175;
	bufferCamera.position.y = 20;
	bufferCamera.position.x = -41;
	bufferCamera.rotation.x = 0.23;
	bufferCamera.translateZ(10.0);
	controls.update();

	options = {
		displacement: 0.8,
		waterLevel: 13.8,//0.5,
		grassyness: 0.77,
		reflectiveness: 0.5
	};
	//gui.add( options, "displacement", 0, 2 );
	//gui.add( options, "waterLevel", 0, 100 );
	//gui.add( options, "grassyness", 0, 1 );
	//gui.add( options, "reflectiveness", 0, 1 );

	scene = new THREE.Scene();

  //=====Skybox=====
  var cubeMap = new THREE.CubeTextureLoader()
    .setPath("./skyboxset1/ThickCloudsWater/")
    .load( [
      'posx.png',
      'negx.png',
      'posy.png',
      'negy.png',
      'posz.png',
      'negz.png'
    ] );

  var uniformsSB = { "tCube": { type: "t", value: cubeMap } };

  var materialSB = new THREE.RawShaderMaterial( {
    uniforms: uniformsSB,
    vertexShader: sb_vs,
    fragmentShader: sb_fs
  } );

  materialSB.depthWrite = false;
  materialSB.side = THREE.BackSide;

  var geometrySB = new THREE.BoxGeometry( 2000, 2000, 2000 );
  skyMesh = new THREE.Mesh( geometrySB, materialSB );
  bufferScene.add( skyMesh );

  //====SEA====
  var seaGeometry = new THREE.PlaneGeometry(400, 400, 100, 100);

  var seaUniforms = {
    seaTex: {type: "t", value: texture2},
    envMap: {type: "t", value: cubeMap},
    uTime: {type: "float", value: 0.0},
    reflectiveness: {type: "float", value: options.reflectiveness},
  };

  var seaMaterial = new THREE.RawShaderMaterial({
    uniforms: seaUniforms,
    vertexShader: sea_vs,
    fragmentShader: sea_fs,
  });


  var seaMesh = new THREE.Mesh(seaGeometry, seaMaterial);
  seaMesh.material.side = THREE.DoubleSide;
  seaMesh.rotateX(-Math.PI/2);
  seaMesh.translateZ(0.0);
  seaMesh.name = "sea";
  bufferScene.add(seaMesh);

	//terrain
	iceland = CreateTerrain(400.0, 400.0, cubeMap);
	iceland.rotation.x = - Math.PI / 2.0;
	iceland.translateZ(0.0);
	bufferScene.add( iceland );
	
	//======Snow======
	var snowUniforms = {
		rx: {type: "f", value: window.innerWidth*1.3},
        ry: {type: "f", value: window.innerHeight*1.3},
		time: {type: "f", value: 0.0},
		textureBuffer: {type: "t"},
	};
	var snowMaterial = new THREE.RawShaderMaterial( {
		uniforms: snowUniforms,
		vertexShader: snow_vs,
		fragmentShader: snow_fs,
	} );
	var snowScreen = new THREE.PlaneGeometry( window.innerWidth, window.innerHeight);
	var fullSnowQuad = new THREE.Mesh( snowScreen, snowMaterial );
	scene.add(fullSnowQuad);

	renderer = new THREE.WebGLRenderer();
	renderer.setClearColor( 0x999999 );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	container.appendChild( renderer.domElement );

  window.addEventListener( 'resize', onWindowResize, false );
}

function onWindowResize( event ) {
  bufferCamera.aspect = window.innerWidth / window.innerHeight;
  bufferCamera.updateProjectionMatrix();
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}
function animate() {
  requestAnimationFrame( animate );
  render();
}

function render() {
	var time = performance.now();
	var sea = bufferScene.getObjectByName("sea");
	//object0.material.uniforms.displaceAmt.value = 0.5 * (1.0 + Math.sin(time * 0.001));
	sea.position.set(sea.position.x, options.waterLevel, sea.position.z);
	sea.material.uniforms.reflectiveness.value = options.reflectiveness;
	sea.material.uniforms.uTime.value = time * 0.0005;
	var object1 = scene.children[ 0 ];
	object1.material.uniforms.time.value = time * 0.005;
	renderer.render(bufferScene,bufferCamera,bufferObject);
	object1.material.uniforms.textureBuffer.value = bufferObject.texture;
	renderer.render( scene, camera );
}
	</script>

	</body>
</html>
